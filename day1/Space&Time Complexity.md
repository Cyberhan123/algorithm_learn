#  时间复杂度和空间复杂度
##  时间复杂度
看一下学校老师的解释：
<p align="center">
  <img src="https://github.com/Cyberhan123/algorithm_learn/blob/master/day1/src/day1-1.png">
</p>
完蛋了要上天了，其实。。。我查了一下百度

###  时间复杂度到底是什么？？？

这个时间复杂度就是表示代码执行的次数（百度上叫计算机执行一次运算）

-  比如  ```
       printf("Hello, World!\n");      //  需要执行 1 次
       return 0;       // 需要执行 1 次
        ```
    -  Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。
       当出现 T(n) = n + 29，此时时间复杂度为 O(n)。就是把常数给省略了
       
    -  我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。
       所以有:
       ```T(n) = n^3 + n^2 + C，此时时间复杂度为 O(n^3)。(C为常数)```

-  对于循环
    
    -  一重循环：
        ```for(int i = 0; i < n; i++) {         // 循环次数为 n
               printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
           }
        ```
        就会有
        对于一个循环，循环执行一次的的时间复杂度为 O(n)，循环次数为 m，则这个
        循环的时间复杂度为 O(n×m)。
    
    -  对于多个循环：
        ```
        for(int i = 0; i < n; i++) {         // 循环次数为 n
                for(int j = 0; j < n; j++) {       // 循环次数为 n
                    printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
                }
            }
        ```
        假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。
        分析的时候应该由里向外分析这些循环。

-  顺序执行的语句或者算法:
    
    ```// 第一部分时间复杂度为 O(n^2)
           for(int i = 0; i < n; i++) {
               for(int j = 0; j < n; j++) {
                   printf("Hello, World!\n");
               }
           }
           // 第二部分时间复杂度为 O(n)
           for(int j = 0; j < n; j++) {
               printf("Hello, World!\n");
           }
    ```
    
      总的时间复杂度等于其中最大的时间复杂度。O(n^2)
    
   -  条件判断语句:
    
    ```
    if (n >= 0) {
            // 第一条路径时间复杂度为 O(n^2)
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    printf("输入数据大于等于零\n");
                }
            }
        } else {
            // 第二条路径时间复杂度为 O(n)
            for(int j = 0; j < n; j++) {
                printf("输入数据小于零\n");
            }
        }
    ```
    
    总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。O(n^2)

###  算法复杂性在渐近意义下的阶
下面是学校给的定义，又是什么意思呢？？？


-  渐近意义下的记号：O、Ω、θ、o

-  设f(N)和g(N)是定义在正数集上的正函数

-  O的定义：如果存在正的常数C和自然数N0，使得当N≥N0时有f(N)≤Cg(N)，
则称函数f(N)当N充分大时上有界，且g(N)是它的一个上界，记为f(N)=O(g(N))。即f(N)的阶不高于g(N)的阶

-  根据O的定义，容易证明它有如下运算规则
        O(f)+O(g)=O(max(f,g))
        O(f)+O(g)=O(f+g)
        O(f)O(g)=O(fg)
        如果g(N)=O(f(N))，则O(f)+O(g)=O(f)
        O(Cf(N))=O(f(N))，其中C是一个正的常数
这都是什么呢，其实就是把我上面的那个就近取值给用公式表达了
Orz 果然数学好就是可以为所欲为QAQ
##  空间复杂度(预计 2018/9/4 更新，抱歉今天完成QvQ了)
今天ML  🕊 了，GitHub pull的好慢，无奈放弃。
- 空间复杂度，它是对一个算法在运行过程中临时占用存储空间大小的量度。所以它强调的是使用的辅助空间的的大小，
而不是指所有的数据所占用的空间。

- 这个代码(瞎交换变量)
    ```
        long long a=0;
        long long b=1;
        long long c=0;
        for(int i=2;i<=n;i++)
        {
            c=a+b;
            a=b;
            b=c;
        }
	
	```
	- 这是非递归的另一种算法，函数真正执行次数依然为n-1,所以忽略常数后，时间复杂度还是O(n);
由于采用变量交换的方式，所以在这里辅助空间个数为一个常数，空间复杂度为O(1).





- 例如：这个代码(斐波那契)
    
    ```
    long long* p=new long long[n+1];
    p[0]=0;
    p[1]=1;
    for(int i=2;i<=n;++i)
    {
        p[i]=p[i-1]+p[i-2];
    }
   ```
    - 对于这种算法，函数真正执行次数为n-1,
    所以忽略常数后，时间复杂度为O(n);
    因为开辟了n+1个空间，有n+1个辅助空间，所以空间复杂度为O(n).

-  例如：这个代码（瞎乱递归）
    ```
    long long fun(long long n)
    {
        return (fun(n+1));
    }
    ```
    -  显而易见这个代码取决于n 所以O(n)
    
# 结尾
预告： 第二天 我要写这两个的进阶，就是课本上万恶的公式，
并且努力弄懂他们  QAQ
    