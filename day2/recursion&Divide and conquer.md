# 递归和分而治之
## 递归
直接或间接调用自身的算法叫递归

举个例子 ：

```
int add(int a,int b){
    if(a<b)
    return add(a+b,6);
}
```
妥，虽然这个代码有点强行递归的意思，但是不争的事实，它就是递归

- 经典小例子：
    - Fibonacci数列
    
        斐波那契数列就是当这个数列中的任意一个数大于1时，它等于它的前两项之和

        ```
        int fibonacci(int n){
            if(n<=1) return 1;
            return fibonacci(n-1)+fibonacci(n-2);
        }
        ```
        看见这个算法我是蒙圈的哦，为什么第n个是这么递归的啊？
        
        那我仔细分析一下，先列上前几个好照葫芦画瓢找规律。
        ```
        fibonacci :1,1,2,3,5,8,13
        n:         0,1,2,3,4,5, 6
        ```
        1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----------0

        1   &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----------1

        2=1+1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ----2

        3=2+1=1+1+1&#160;-----3

        5=3+2=2+1+2&#160;-----4

        8=5+3=3+2+3&#160;-----5
        
        ....

        F(n)=F(n-1)+F(n-2)

        那么不数学的民科证明就完成了，

        总结：

        F(n)=
        
        { <br>
            1     &#160;&#160;&#160;&#160;      n=1,0
            <br/>
            F(n)=F(n-1)+F(n-2)  &#160;&#160;&#160;&#160; n>1

        }

        反正公式我是记不住QAQ

    - Ackerman 函数
  
        有的时候递归的问题只能用递归解开，别老是想for循环暴力了。
        那么，我也不想研究这个恶心的动心先扔着，mark一下等完成了我给勾上QAQ

        <input type="checkbox">研究完成（看样子是不存在的）

    - 排序问题： emmmm我等有时间单开一下研究一下排序
    
    - 整数划分问题
        
        这个整数划分有点烦啊
        就是：
        
        3有3种

        3

        2+1,
        
        1+1+1

        5有7种情况

        5

        4+1，

        3+2，3+1+1

        2+2+1，2+1+1+1

        1+1+1+1+1

        这样一写就简单了，n的正整数划分:

        在起始数为1时候只有一种形式就是1+1+1+....

        在起始数是n-1的时候是(n-1)+1
        也是一种形式。

        设在正整数n的所有不同划分中，最大加数（起始数）为m 则将其个数记作q(n,m)
        因为起始数总是大于之后的数并且总有q(n,m)=q(n,m-1)+q(n-m,m)

        于是有
        ```
        int q(int n, int m)
        {
            if (n < 1 || m < 1)
                return 0;
            if (n == 1 || m == 1)
                return 1;
            if (n < m)
                //当n<m的时候让n=m
                return q(n, n);
            if (n == m)
                //当n==m
                return q(n, m - 1) + 1;
            return q(n, m - 1) + q(n - m, m);
        }
        ```

    - Hanoi 塔问题

        
