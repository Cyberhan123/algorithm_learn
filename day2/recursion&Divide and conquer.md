# 递归和分而治之
## 递归
直接或间接调用自身的算法叫递归

举个例子 ：

```
int add(int a,int b){
    if(a<b)
    return add(a+b,6);
}
```
妥，虽然这个代码有点强行递归的意思，但是不争的事实，它就是递归

- 经典小例子：
    - Fibonacci数列
    
        斐波那契数列就是当这个数列中的任意一个数大于1时，它等于它的前两项之和

        ```
        int fibonacci(int n){
            if(n<=1) return 1;
            return fibonacci(n-1)+fibonacci(n-2);
        }
        ```
        看见这个算法我是蒙圈的哦，为什么第n个是这么递归的啊？
        
        那我仔细分析一下，先列上前几个好照葫芦画瓢找规律。
        ```
        fibonacci :1,1,2,3,5,8,13
        n:         0,1,2,3,4,5, 6
        ```
        1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----------0

        1   &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----------1

        2=1+1 &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ----2

        3=2+1=1+1+1&#160;-----3

        5=3+2=2+1+2&#160;-----4

        8=5+3=3+2+3&#160;-----5
        
        ....

        F(n)=F(n-1)+F(n-2)

        那么不数学的民科证明就完成了，

        总结：

        F(n)=
        
        { <br>
            1     &#160;&#160;&#160;&#160;      n=1,0
            <br/>
            F(n)=F(n-1)+F(n-2)  &#160;&#160;&#160;&#160; n>1

        }

        反正公式我是记不住QAQ

    - Ackerman 函数
  
        有的时候递归的问题只能用递归解开，别老是想for循环暴力了。
        那么，我也不想研究这个恶心的动心先扔着，mark一下等完成了我给勾上QAQ

        <input type="checkbox">研究完成（看样子是不存在的）

    - 排序问题： emmmm我等有时间单开一下研究一下排序
    
    - 整数划分问题
        
        这个整数划分有点烦啊
        就是：
        
        3有3种

        3

        2+1,
        
        1+1+1

        5有7种情况

        5

        4+1，

        3+2，3+1+1

        2+2+1，2+1+1+1

        1+1+1+1+1

        这样一写就简单了，n的正整数划分:

        在起始数为1时候只有一种形式就是1+1+1+....

        在起始数是n-1的时候是(n-1)+1
        也是一种形式。

        设在正整数n的所有不同划分中，最大加数（起始数）为m 则将其个数记作q(n,m)
        因为起始数总是大于之后的数并且总有q(n,m)=q(n,m-1)+q(n-m,m)

        于是有
        ```
        int q(int n, int m)
        {
            if (n < 1 || m < 1)
                return 0;
            if (n == 1 || m == 1)
                return 1;
            if (n < m)
                //当n<m的时候让n=m
                return q(n, n);
            if (n == m)
                //当n==m
                return q(n, m - 1) + 1;
            return q(n, m - 1) + q(n - m, m);
        }
        ```

    - Hanoi 塔问题
        
        Hanoi：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

        规则：
        
        1. 每次只能移动一个圆盘
        
        2. 任何时刻都不允许将较大的圆盘压在较小的圆盘之上
   
        3. 在满足前两条规则下可以将圆盘移动到任意塔上
   
        ```
        void hanoi(int n,int a,int b,int c){
            if(n>0){
                hanoi(n-1,a,c,b);
                move(a,b);
                hanoi(n-1,c,b,a);
            }
        }
        ``` 
##  分而治之
分而治之：所谓“分而治之” 就是把一个复杂的算法问题按一定的“分解”方法分为等价的规模较小的若干部分，然后逐个解决，分别找出各部分的解，把各部分的解组成整个问题的解

- 经典小例子：
    - 二分搜索

        二分搜索是将n个元素分成两半，取n/2与x进行比较，直到满足x=n/2
    - 大整数乘法
    - Strassen 矩阵乘法
    - 棋盘覆盖
    - 合并排序
    - 快速排序
    - 线性时间选择
    - 最接近点对点问题




        
